# data file for the Fltk User Interface Designer (fluid)
version 1.0104 
header_name {.h} 
code_name {.cxx}
decl {\#include <stdio.h>} {public
} 

decl {\#include <iostream>} {public
} 

decl {\#include <sstream>} {public
} 

decl {\#include <FL/Fl.H>} {public
} 

decl {\#include <FL/Fl_Window.H>} {public
} 

decl {\#include <FL/Fl_Menu_Bar.H>} {public
} 

decl {\#include <FL/Fl_Box.H>} {public
} 

decl {\#include <FL/Fl_File_Chooser.H> 
\#include <FL/Fl_Hold_Browser.H> 
\#include <FL/Fl_File_Icon.H> 
\#include <FL/Fl_Shared_Image.H> 
\#include <FL/Fl_PNM_Image.H>} {public
} 

decl {char *statlabel;
 std::string filename_alt;
 bool setTitleUrl = true;
 using namespace std;
 int px,py,pw,ph;
 int fullscreen;} {} 

decl {class TagDrawings;
class TagBrowser;
class TagTexts;} {public
} 

decl {\#include <openvrml/browser.h>} {public
} 

decl {\#include <openvrml/gl/viewer.h>} {public
} 

decl {\#include "vFLGLWidget.h"} {public
} 

decl {\#include "ViewerFLTK.h"} {public
} 

decl {openvrml::browser *browser = 0;} {} 

decl {ViewerFLTK  *viewer = 0;} {} 

decl {//\#define DBG cout << __FILE__<<":"<<__LINE__ <<" "<< __func__ << "()" << endl;} {public
} 

decl {\#define _(text) text} {public
} 

decl {\#include "icc_draw.h"} {} 

decl {\#include "icc_profile.h"
\#include "icc_utils.h"} {public
} 

decl {ICCprofile profile;} {public
} 

Function {} {open C return_type int
} {
  code {statlabel = (char*)calloc (sizeof (char), 1024);
  fullscreen = false;} {}
  Fl_Window details {
    label {ICC Details} open
    xywh {572 242 385 520} type Double box NO_BOX color 53
    code0 {browser = new openvrml::browser(cout, cerr);}
    code1 {DBG
    if (argc>1) {
      std::vector<std::string> url;
      std::vector<std::string> param;

      if (browser && argc>1) {
        url.push_back (argv[1]);
        browser->load_url(url, param);
        sprintf (statlabel, "%s geladen", argv[1]);
        stat->label(statlabel);
        filename_alt = argv[1];
      } else {
        stat->label("Error loading file!");
      }
    } // if}
    code2 {DBG
    browser->add_world_changed_callback( worldChangedCB );
    worldChangedCB( openvrml::browser::replace_world_id );}
    code3 {DBG
    viewer = new ViewerFLTK( *browser, canvas );
    canvas->setViewerPtr( viewer );} xclass Fl_Window visible
  } {
    Fl_Group {} {open
      xywh {0 0 385 520}
    } {
      Fl_Menu_Bar Fl_lookat_MenuBar {open
        xywh {0 0 385 25} color 53 align 20 when 3
      } {
        submenu {} {
          label Daten open
          xywh {15 15 100 20}
        } {
          menuitem {} {
            label Offnen
            callback {open(true)}
            xywh {15 15 100 20} shortcut 0x4006f
          }
          menuitem {} {
            label Beenden
            callback {quit()}
            xywh {15 15 100 20} shortcut 0x40071
          }
        }
        submenu {} {
          label Ansicht open
          xywh {15 15 100 20}
        } {
          menuitem Voll {
            label {Ganzer Bildschirm}
            callback {Fl_Window *w = (Fl_Window *)details;

  if (!fullscreen) {
    px = w->x();
    py = w->y();
    pw = w->w();
    ph = w->h();

    w->fullscreen();
    fullscreen = true;
  }}
            xywh {15 15 100 20}
          }
          menuitem normal_ansicht {
            label {normales Fenster}
            callback {Fl_Window *w = (Fl_Window *)details;

    w->fullscreen_off(px,py,pw,ph);
    fullscreen = false;}
            xywh {25 25 100 20}
          }
        }
      }
      Fl_Group {} {open
        xywh {0 495 385 25}
      } {
        Fl_Box stat {
          label {No wrl file loaded.}
          xywh {0 495 385 25} box THIN_DOWN_BOX color 53 align 20
        }
        Fl_Progress load_progress {
          label {Laden ..}
          xywh {0 495 385 25} color 53
          code0 {o->hide();}
          code1 {o->maximum(1.0);}
          code2 {o->minimum(0.0);}
        }
      }
      Fl_Tile {} {open
        xywh {0 25 385 470}
      } {
        Fl_Browser tag_browser {
          label {Bitte wählen Sie ein Profilmerkmal aus}
          callback {o->select_item( o->value() );}
          xywh {0 25 385 135} color 53 align 17
          code0 {int lines = tag_browser->size();}
          code1 {cout << lines << endl; DBG}
          class TagBrowser
        }
        Fl_Group ansichtsgruppe {open
          xywh {0 160 385 335}
        } {
          Fl_Box tag_viewer {
            xywh {0 160 385 335}
            code0 {o->hide();}
            class TagDrawings
          }
          Fl_Box canvas {
            label OpenVRML
            xywh {0 160 385 335} align 16 hide
            code0 {o->hide();}
            class vFLGLWidget
          }
          Fl_Browser tag_texts {
            label {Der Text}
            xywh {0 160 385 335} color 53 align 18
            class TagTexts
          }
        }
      }
    }
  }
  code {w->resizable(tag_texts);
  w->show();
  canvas->hide();
  viewer->Hok=1;
  viewer->Hdraw=1;
  viewer->timerUpdate();
  viewer->handleRedraw();
  Fl::add_timeout(0.01, (void (*)(void *))timeIT, (void *)viewer);

  Fl::scheme(NULL);
  Fl_File_Icon::load_system_icons();
  if (argc > 1)
    open (false);} {}
} 

Function {open(int interaktiv)} {open return_type {std::string}
} {
  code {\#include "icc_vrml.h"

  std::string filename = filename_alt;
  Fl_File_Icon	*icon;	// New file icon
  DBG
  load_progress->show ();    load_progress->value (0.0);
  char vrmlDatei[] = "/tmp/tmp_vrml.wrl";

  if (interaktiv)
    filename=fl_file_chooser("Wähle ICC Profil?", "ICC Farbprofile (*.[I,i][C,c][M,m,C,c])", filename_alt.c_str());
  DBG cout << filename_alt << endl;

  if (filename == "") {
    load_progress->hide ();
    return "";
  }

  // Laden
  profile.load (filename);
  // Register the ICC type ...
  //Fl_Shared_Image::add_handler(icc_check);
  //Fl_Shared_Image::add_handler(ps_check);

  std::vector<std::string> url;
  std::vector<std::string> param;

  if (browser && (filename != "")) { DBG

    create_vrml ( filename.c_str(), "/usr/share/color/icc/sRGB.icm", &vrmlDatei[0]);

    load_progress->value (0.8);
    filename_alt = filename;
    url.push_back (&vrmlDatei[0]);
    browser->load_url(url, param);
    sprintf (statlabel, "%s geladen", filename.c_str());
    cout << statlabel << endl;
    stat->label(statlabel);
    DBG
  } else {
    stat->label("Error loading file!");
  } DBG

  stat->hide();
  stat->show();
  load_progress->value (1.0);
  viewer->timerUpdate();
  viewer->handleRedraw();
  load_progress->value (0.0);
  load_progress->hide();
  DBG

  tag_browser->reopen ();

  return filename;} {selected
  }
} 

Function {quit(void)} {} {
  code {Fl::remove_timeout((void (*)(void *))timeIT, (void *)viewer);
  delete viewer;
  delete browser;
  delete canvas;
  details->hide();
  exit(0);} {}
} 

Function {worldChangedCB( const openvrml::browser::cb_reason reason )} {} {
  code {switch (reason)
    {
        case openvrml::browser::destroy_world_id:
            delete browser;
            delete viewer;
            Fl::remove_timeout((void (*)(void *))timeIT, (void *)viewer);
            exit(0);
            break;
        case openvrml::browser::replace_world_id: DBG
            if (setTitleUrl) { DBG
                stat->label(statlabel);//browser->world_url().c_str());
            }
            //buildViewpointMenu();
            break;
            DBG
    }} {}
} 

Function {timeIT()} {} {
  code {if (canvas->LeftViewer == 0) {
    viewer->timerUpdate();
    viewer->handleRedraw();
  }
  Fl::add_timeout(0.01, (void (*)(void *))timeIT, (void *)viewer);} {}
} 

Function {icc_read_info(char* filename)} {return_type {char*}
} {
  code {char systemBefehl[1024];
  char *textfile = "/tmp/icc_temp.txt";


  sprintf (systemBefehl, "iccdump \\"%s\\" > %s",
                                    filename, textfile);
  system (systemBefehl);

  return textfile;} {}
} 

class TagTexts {: {public Fl_Hold_Browser}
} {
  decl {int X; int Y; int W; int H; char* start_info;} {}
  Function {TagTexts(int X,int Y,int W,int H,char* start_info) : Fl_Hold_Browser(X,Y,W,H,start_info), X(X), Y(Y), W(W), H(H)} {open
  } {}
  Function {hinein(std::string text)} {open
  } {
    code {//Text aus tag_browser anzeigen

  canvas->hide(); DBG
  tag_viewer->hide(); DBG
  tag_viewer->clear_visible(); DBG
  tag_texts->show(); DBG

      tag_texts->clear();
      int len = strlen(text.c_str());
      std::string text_line;
      char c;
      const char *chars = text.c_str();
      for (int zeichen = 0; zeichen < len; zeichen++) {
        c = chars[zeichen];
        if (c == '\\n' || (int)c == 0) {
          text_line += '\\0';
          tag_texts->add(text_line.c_str(), 0);
          text_line.clear();
        } else
          text_line += c;
      }
      if (text_line.size() > 0)
        tag_texts->add(text_line.c_str(), 0);

      tag_texts->topline(0);
      tag_texts->textfont(FL_COURIER);
      tag_texts->textsize(14);} {}
  }
} 

class TagDrawings {: {public Fl_Widget}
} {
  decl {int X; int Y; int W; int H; std::vector<std::string>texte; std::vector<double>punkte; std::vector<std::vector<double> >kurven;} {}
  decl {int wiederholen;} {public
  }
  Function {TagDrawings(int X,int Y,int W,int H) : Fl_Widget(X,Y,W,H), X(X), Y(Y), W(W), H(H)} {open
  } {}
  Function {draw()} {open
  } {
    code {// Kurven oder Punkte malen
  cout << punkte.size() << " " << kurven.size() << " "; DBG

  if (punkte.size() >= 3) {
    wiederholen = true;
    draw_cie_shoe(x(),y(),w(),h(),texte,punkte,false);
    Fl::add_timeout( 1.2, (void(*)(void*))d_haendler ,(void*)this);

  } else {
    wiederholen = false;
    draw_kurve   (x(),y(),w(),h(),texte,kurven);
  }
  //DBG} {}
  }
  Function {hinein_punkt(std::vector<double> vect, std::vector<std::string> txt)} {open
  } {
    code {//CIExyY aus tag_browser anzeigen
  punkte = vect;
  texte = txt;
  kurven.clear();

  canvas->hide(); DBG
  tag_viewer->show(); DBG
  tag_texts->hide(); DBG} {}
  }
  Function {hinein_kurve(std::vector<double> vect, std::vector<std::string> txt)} {open
  } {
    code {//Kurve aus tag_browser anzeigen
  kurven.clear();
  kurven.push_back(vect);
  texte = txt;
  punkte.clear();

  canvas->hide(); DBG
  tag_viewer->show(); DBG
  tag_texts->hide(); DBG} {}
  }
  Function {ruhig_neuzeichnen(void)} {open return_type void
  } {
    code {draw_cie_shoe(x(),y(),w(),h(),texte,punkte,true);} {}
  }
} 

class TagBrowser {: {public Fl_Hold_Browser}
} {
  decl {int X; int Y; int W; int H; char* start_info;} {}
  Function {TagBrowser(int X,int Y,int W,int H,char* start_info) : Fl_Hold_Browser(X,Y,W,H,start_info), X(X), Y(Y), W(W), H(H)} {open
  } {}
  Function {reopen()} {open
  } {
    code {//open and preparing the first selected item
  std::stringstream s;
  std::string text;
  std::vector<std::string> tag_list = profile.printTags();

  \#define add_s(stream) s << stream; add (s.str().c_str()); s.str("");
  \#define add_          s << " ";

  clear();
  add_s ("@fDateiname:")
  add_s ("@b    " << profile.filename() )
  add_s ("")
  if (tag_list.size() == 0) {
    add_s ("keine Inhalte gefunden fŸr \\"" << profile.filename() << "\\"")
    return;
  }
  add_s ("@B26@tNr. Bezeichner  Typ         Größe Beschreibung")
  add_s ("@t" << profile.printHeader() )
  DBG
  std::vector<std::string>::iterator it;
  for (it = tag_list.begin() ; it != tag_list.end(); ++it) {
    s << "@t";
    // Nummer
    int Nr = atoi((*it).c_str()) + 1;
    stringstream t; t << Nr;
    for (int i = t.str().size(); i < 3; i++) {s << " ";} s << Nr; *it++; s << " "; 
    // Name/Bezeichnung
    s << *it; for (int i = (*it++).size(); i < 12; i++) {s << " ";}
    // Typ
    s << *it; for (int i = (*it++).size(); i < 12; i++) {s << " ";}
    // Gršße
    for (int i = (*it).size(); i < 5; i++) {s << " ";} s << *it++; s << " ";
    // Beschreibung
    add_s (*it)
  }
  DBG
  if (value())
    select_item (value()); // Anzeigen
  else
    select_item (1);

  s.clear(); s << "ICC Details: " << profile.filename();
  details->label( (const char*) s.str().c_str() );} {}
  }
  Function {select_item(int item)} {open
  } {
    code {//Auswahl aus tag_browser
  std::string text = _("Leer");
  tag_texts->hinein(text);
  item -= 6;
  cout << item << ". Tag "; DBG

  if (item < 0) {
    select(5);
    text = profile.printLongHeader(); DBG
    tag_texts->hinein(text);    
  } else if (item >= 0) {
    std::vector<std::string> TagInfo = profile.printTagInfo(item);
    cout << TagInfo.size() << " " << TagInfo[0] << TagInfo[1] << " "; DBG

    if        ( TagInfo[1] == "text" ) {
      tag_texts->hinein ( profile.getTagText (item));
    } else if ( TagInfo[1] == "XYZ"  ) {
      tag_viewer->hinein_punkt( profile.getTagCIExy(item), TagInfo );
    } else if ( TagInfo[1] == "curv" ) {
      tag_viewer->hinein_kurve( profile.getTagCurve(item), TagInfo );
    } else if ( TagInfo[0] == "text" ) {
    }
  }DBG} {}
  }
} 

Function {d_haendler(void* o)} {open return_type {static void}
} {
  code {Fl::remove_timeout( (void(*)(void*))d_haendler, 0 );
  if (!Fl::has_timeout( (void(*)(void*))d_haendler, 0 )
   && ((TagDrawings*)o)->visible_r()
   && ((TagDrawings*)o)->wiederholen) {
    ((TagDrawings*)o)->ruhig_neuzeichnen();
  }} {}
} 
